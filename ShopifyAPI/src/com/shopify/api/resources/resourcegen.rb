=begin
Current this will scrape through the fixtures and generate new class
implementations based on the training data.

It would be cool if we took a MOGenerator approach and created intermediate classes
say... _YourResource and overwrote those every time.

Then we could generate YourResource classes only if the file doesn't exist.

This means we could make super awesome changes to the API and run the code generator
and not completely hose all of our custom model code.
=end

require 'rubygems'
require 'active_support/all'
require 'json'
require 'date'

resources_location = "../../../../../../ShopifyAPITests/assets/fixtures"

resources = Dir.entries(resources_location).reject{|x| ["..", "."].include? x}

def determine_type(value)
  if value.class == Fixnum
    return "int"
  elsif value.class == Float
    return "float"
  elsif value.class == TrueClass || value.class == FalseClass
    return "boolean"
  else
    return "String"
  end
end

def generate_java(className, superClass, hash, file)
  warning =<<END
/**
* DO NOT MODIFY THIS CODE
* 
* Place all of your changes in #{className[/MG([a-zA-Z0-9|_]+)/, 1]}.java
* 
* It has been machine generated from fixtures and your changes will be
* lost if anything new needs to be added to the API. 
**/
END
  header =<<END
// Last Generated: #{DateTime.now.to_s}
package com.shopify.api.resources;

import org.codehaus.jackson.annotate.JsonProperty;

/**
* This code has been machine generated by processing the single entry
* fixtures found from the Shopify API Documentation
*/
  
public class #{className} extends #{superClass} {

END
  file.write(warning) if className[0,2] == "MG"
  file.write(header)
  hash.each{|resource_name, value|
    next if ["id", "created_at", "updated_at"].include? resource_name
    function_name = resource_name.camelize
    if !value.is_a?(Hash) && !value.is_a?(Array)
      type = determine_type(value)
      # Prefix all names in case they use reserved keywords in the language
      file.write "\t@JsonProperty(\"#{resource_name}\")\n"
      file.write "\tprivate #{type} _#{resource_name};\n"
      file.write "\tpublic #{type} get#{function_name}(){ return _#{resource_name};}\n"
      file.write "\tpublic void set#{function_name}(#{type} _#{resource_name}){_#{resource_name} = this._#{resource_name};}\n"
    else
      file.write "\t// TODO: #{resource_name} is a hash or array\n"
      file.write "\t/* #{value.to_json} */\n"
    end
    file.write "\n"
  }
  file.write("}")
end

resources.each do |fixture_name|
  next unless File.directory? "#{resources_location}/#{fixture_name}"
  next if File.exists? "#{resources_location}/#{fixture_name}/skip"
  begin
    input = File.open("#{resources_location}/#{fixture_name}/single#{fixture_name}.json", 'rb')
    data = JSON.parse(input.read())
    input.close()
    gen_file = "MG#{fixture_name}"
    output = File.open("#{gen_file}.java", 'wb')
    name = data.keys.first
    puts "Writing #{fixture_name}.java to disk"
    generate_java(gen_file, "ShopifyResource", data[name], output)
    output.flush()
    output.close()
    unless File.exists? "#{fixture_name}.java"
      File.open("#{fixture_name}.java", "wb"){|f|
        generate_java(fixture_name, gen_file, {}, f)
      }
    end
  rescue JSON::ParserError => err
    puts "ERROR: Could not write #{fixture_name}.java to disk.  Could the JSON be missing?"
    puts "REASON: #{err}"
    next
  end
end
